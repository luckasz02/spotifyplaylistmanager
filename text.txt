COD INAINTE DE LOGOUT


from flask import Flask, request, jsonify, render_template, redirect, session, url_for
import spotipy
from spotipy.oauth2 import SpotifyOAuth
import os

app = Flask(__name__)
app.secret_key = os.urandom(24).hex()
print(app.secret_key)

# Spotify credentials
CLIENT_ID = '1ad5966625254e428757df1401b110c7'
CLIENT_SECRET = 'a974e67a80ba49b18369efa83a918056'
REDIRECT_URI = 'http://localhost:8888/callback'
SCOPE = 'playlist-modify-public'
sp_oauth = SpotifyOAuth(client_id=CLIENT_ID, client_secret=CLIENT_SECRET, redirect_uri=REDIRECT_URI, scope=SCOPE)

# Checking Login State
@app.route('/check_login', methods=['GET'])
def check_login():
    token_info = session.get('token_info', None)
    return jsonify(bool(token_info))

# Authentication route
@app.route('/login')
def login():
    auth_url = sp_oauth.get_authorize_url()
    return redirect(auth_url)

# Callback route
@app.route('/callback')
def callback():
    code = request.args.get('code')
    token_info = sp_oauth.get_access_token(code)
    session['token_info'] = token_info
    return redirect(url_for('index'))

def get_spotify_client():
    token_info = session.get('token_info', None)
    if not token_info:
        raise Exception("Authentication required")
    if sp_oauth.is_token_expired(token_info):
        token_info = sp_oauth.refresh_access_token(token_info['refresh_token'])
        session['token_info'] = token_info
    return spotipy.Spotify(auth=token_info['access_token'])

@app.route('/get_user_playlists', methods=['GET'])
def get_user_playlists():
    sp = get_spotify_client()
    playlists = sp.current_user_playlists(limit=50)
    return jsonify([{'name': playlist['name'], 'id': playlist['id']} for playlist in playlists['items']])

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/search_tracks', methods=['POST'])
def search_tracks():
    sp = spotipy.Spotify(auth_manager=SpotifyOAuth(client_id=CLIENT_ID,
                                                   client_secret=CLIENT_SECRET,
                                                   redirect_uri=REDIRECT_URI,
                                                   scope=SCOPE))
    track_name = request.json['track_name']
    results = sp.search(q=track_name, limit=10, type='track')
    tracks = [{'name': track['name'], 'id': track['id']} for track in results['tracks']['items']]
    return jsonify(tracks)

@app.route('/add_to_playlist', methods=['POST'])
def add_to_playlist():
    sp = spotipy.Spotify(auth_manager=SpotifyOAuth(client_id=CLIENT_ID,
                                                   client_secret=CLIENT_SECRET,
                                                   redirect_uri=REDIRECT_URI,
                                                   scope=SCOPE))
    playlist_id = request.json['playlist_id']
    track_ids = request.json['track_ids']
    sp.user_playlist_add_tracks(user=sp.current_user()['id'], playlist_id=playlist_id, tracks=track_ids)
    return jsonify({'message': 'Tracks added successfully'})

@app.route('/logout', methods=['POST'])
def logout():
    session.pop('token_info', None)  # Remove the stored token
    return jsonify({"message": "Logged out successfully"})

if __name__ == '__main__':
    app.run(debug=True, port=8888)

# .\venv\Scripts\activate







COD CU LOGOUT SI LOGIN FUNCTIONAL

from flask import Flask, request, jsonify, render_template, redirect, session, url_for, make_response
import spotipy
from spotipy.oauth2 import SpotifyOAuth
import os

app = Flask(__name__)
app.secret_key = os.urandom(24).hex()
print(app.secret_key)

# Spotify credentials
CLIENT_ID = '1ad5966625254e428757df1401b110c7'
CLIENT_SECRET = 'a974e67a80ba49b18369efa83a918056'
REDIRECT_URI = 'http://localhost:8888/callback'
SCOPE = 'playlist-modify-public'
sp_oauth = SpotifyOAuth(client_id=CLIENT_ID, client_secret=CLIENT_SECRET, redirect_uri=REDIRECT_URI, scope=SCOPE, show_dialog=True)

# Checking Login State
@app.route('/check_login', methods=['GET'])
def check_login():
    token_info = session.get('token_info', None)
    response = make_response(jsonify(bool(token_info)))
    response.headers["Cache-Control"] = "no-store, no-cache, must-revalidate, max-age=0"
    response.headers["Pragma"] = "no-cache"
    return response

# Authentication route
@app.route('/login')
def login():
    auth_url = sp_oauth.get_authorize_url()
    return redirect(auth_url)

# Callback route
@app.route('/callback')
def callback():
    code = request.args.get('code')
    token_info = sp_oauth.get_access_token(code)
    session['token_info'] = token_info
    return redirect(url_for('index'))

def get_spotify_client():
    token_info = session.get('token_info', None)
    if not token_info:
        raise Exception("Authentication required")
    if sp_oauth.is_token_expired(token_info):
        token_info = sp_oauth.refresh_access_token(token_info['refresh_token'])
        session['token_info'] = token_info
    return spotipy.Spotify(auth=token_info['access_token'])

@app.route('/get_user_playlists', methods=['GET'])
def get_user_playlists():
    sp = get_spotify_client()
    playlists = sp.current_user_playlists(limit=50)
    return jsonify([{'name': playlist['name'], 'id': playlist['id']} for playlist in playlists['items']])

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/search_tracks', methods=['POST'])
def search_tracks():
    sp = spotipy.Spotify(auth_manager=SpotifyOAuth(client_id=CLIENT_ID,
                                                   client_secret=CLIENT_SECRET,
                                                   redirect_uri=REDIRECT_URI,
                                                   scope=SCOPE))
    track_name = request.json['track_name']
    results = sp.search(q=track_name, limit=10, type='track')
    tracks = [{'name': track['name'], 'id': track['id']} for track in results['tracks']['items']]
    return jsonify(tracks)

@app.route('/add_to_playlist', methods=['POST'])
def add_to_playlist():
    sp = spotipy.Spotify(auth_manager=SpotifyOAuth(client_id=CLIENT_ID,
                                                   client_secret=CLIENT_SECRET,
                                                   redirect_uri=REDIRECT_URI,
                                                   scope=SCOPE))
    playlist_id = request.json['playlist_id']
    track_ids = request.json['track_ids']
    sp.user_playlist_add_tracks(user=sp.current_user()['id'], playlist_id=playlist_id, tracks=track_ids)
    return jsonify({'message': 'Tracks added successfully'})

@app.route('/logout', methods=['POST'])
def logout():
    session.clear()  # Clear the entire session
    response = make_response(jsonify({"message": "Logged out successfully"}))
    response.headers["Cache-Control"] = "no-store, no-cache, must-revalidate, max-age=0"
    response.headers["Pragma"] = "no-cache"
    return response

if __name__ == '__main__':
    app.run(debug=True, port=8888)

# .\venv\Scripts\activate


JAVASCRIPT

<script>
      function loginWithSpotify() {
        window.location.href = "/login";
      }

      async function checkLoginState() {
        const response = await fetch("/check_login");
        const isLoggedIn = await response.json();

        const loginSection = document.getElementById("loginSection");
        const playlistManager = document.getElementById("playlistManager");

        if (isLoggedIn) {
          loginSection.style.display = "none";
          playlistManager.style.display = "block";
          logoutButton.style.display = "block";
          loadUserPlaylists();
        } else {
          loginSection.style.display = "block";
          playlistManager.style.display = "none";
          logoutButton.style.display = "none";
        }
      }

      async function loadUserPlaylists() {
        const response = await fetch("/get_user_playlists");
        const playlists = await response.json();
        const playlistList = document.getElementById("playlistList");
        playlists.forEach((playlist) => {
          const option = document.createElement("option");
          option.value = playlist.id;
          option.text = playlist.name;
          playlistList.appendChild(option);
        });
      }
      async function searchTracks() {
        const trackName = document.getElementById("trackName").value;
        const response = await fetch("/search_tracks", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ track_name: trackName }),
        });
        const tracks = await response.json();
        const trackList = document.getElementById("trackList");

        // Append only the first two results of the new search to the list
        for (let i = 0; i < tracks.length && i < 1; i++) {
          const option = document.createElement("option");
          option.value = tracks[i].id;
          option.text = tracks[i].name;
          trackList.appendChild(option);
        }
      }

      async function addToPlaylist() {
        const selectedOptions = Array.from(
          document.getElementById("trackList").selectedOptions
        );
        const trackIds = selectedOptions.map((option) => option.value);
        const playlistId = document.getElementById("playlistList").value;
        await fetch("/add_to_playlist", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            playlist_id: playlistId,
            track_ids: trackIds,
          }),
        });
        alert("Tracks added to playlist successfully");
      }

      function logout() {
        fetch("/logout", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
        }).then(() => {
          window.location.href = "/";
        });
      }

      window.onload = checkLoginState;
    </script>


COD SHUFFLE

shuffle code

import spotipy
from spotipy.oauth2 import SpotifyOAuth
import random
from dotenv import load_dotenv
import os
import tkinter as tk
from tkinter import messagebox

load_dotenv()

client_id = '1cac8869d8e5451ca26b99fea94f6241'
client_secret = '017abb478ffa4685a114e939064e790c'
redirect_uri = 'http://localhost:8888/callback/'

scope = 'playlist-modify-public playlist-modify-private'

auth_manager = SpotifyOAuth(client_id=client_id, client_secret=client_secret, redirect_uri=redirect_uri, scope=scope)
sp = spotipy.Spotify(auth_manager=auth_manager)\


playlist_id = '5tZyTbhPdKDVMaSsbau736'

# Function to shuffle and update the playlist
def shuffle_playlist():
    try:
        tracks = get_playlist_tracks(playlist_id)
        random.shuffle(tracks)
        replace_playlist_tracks(playlist_id, tracks)
        messagebox.showinfo("Success", "Playlist shuffled successfully!")
    except Exception as e:
        messagebox.showerror("Error", str(e))

# Fetch playlist tracks
def get_playlist_tracks(playlist_id):
    results = sp.playlist_tracks(playlist_id)
    tracks = results['items']
    while results['next']:
        results = sp.next(results)
        tracks.extend(results['items'])
    return [track['track']['id'] for track in tracks if track['track']]

# Replace tracks in the playlist
def replace_playlist_tracks(playlist_id, tracks):
    sp.playlist_replace_items(playlist_id, tracks[:100])
    if len(tracks) > 100:
        for i in range(100, len(tracks), 100):
            sp.playlist_add_items(playlist_id, tracks[i:i+100])

# Creating the GUI
def create_gui():
    root = tk.Tk()
    root.title("Spotify Playlist Shuffler")

    shuffle_button = tk.Button(root, text="Shuffle", command=shuffle_playlist)
    shuffle_button.pack(pady=20)

    root.mainloop()

if __name__ == "__main__":
    create_gui()


COD PERFECT FUNCTIONAL INAINTE DE SHUFFLE

from flask import Flask, request, jsonify, render_template, redirect, session, url_for, make_response
import spotipy
from spotipy.oauth2 import SpotifyOAuth
import os
from datetime import timedelta
from werkzeug.middleware.proxy_fix import ProxyFix

app = Flask(__name__)
app.secret_key = os.urandom(24).hex()
print(app.secret_key)
app.config['PERMANENT_SESSION_LIFETIME'] = timedelta(minutes=30) # Session timeout after 30 minutes
app.permanent_session_lifetime = timedelta(minutes=30)
app.wsgi_app = ProxyFix(app.wsgi_app)

# Spotify credentials
CLIENT_ID = '1ad5966625254e428757df1401b110c7'
CLIENT_SECRET = 'a974e67a80ba49b18369efa83a918056'
REDIRECT_URI = 'http://localhost:8888/callback'
SCOPE = 'playlist-modify-public'
sp_oauth = SpotifyOAuth(
    client_id=CLIENT_ID,
    client_secret=CLIENT_SECRET,
    redirect_uri=REDIRECT_URI,
    scope=SCOPE,
    show_dialog=True,
    cache_path=None  # Disable local token caching
)

# Checking Login State
@app.route('/check_login', methods=['GET'])
def check_login():
    token_info = session.get('token_info', None)
    response = make_response(jsonify(bool(token_info)))
    response.headers["Cache-Control"] = "no-store, no-cache, must-revalidate, max-age=0"
    response.headers["Pragma"] = "no-cache"
    return response

# Authentication route
@app.route('/login')
def login():
    print(f"Session before login: {session}")  # Debug: Confirm session is empty
    auth_url = sp_oauth.get_authorize_url()
    return redirect(auth_url)

# Callback route
@app.route('/callback')
def callback():
    code = request.args.get('code')
    token_info = sp_oauth.get_access_token(code)
    session['token_info'] = token_info
    return redirect(url_for('index'))

# Get Spotify client
def get_spotify_client():
    token_info = session.get('token_info', None)
    if not token_info:
        raise Exception("Authentication required")
    if sp_oauth.is_token_expired(token_info):
        session.clear()
        raise Exception("Authentication required")
    print(f"Current token info: {token_info}")  # Debug token info
    return spotipy.Spotify(auth=token_info['access_token'])

# Get user playlists
@app.route('/get_user_playlists', methods=['GET'])
def get_user_playlists():
    sp = get_spotify_client()
    user = sp.current_user()
    print(f"Fetching playlists for user: {user['display_name']} ({user['id']})")  # Debug info
    playlists = sp.current_user_playlists(limit=50)
    return jsonify([{'name': playlist['name'], 'id': playlist['id']} for playlist in playlists['items']])

# Route to render index.html template
@app.route('/')
def index():
    return render_template('index.html')

# Route to search tracks
@app.route('/search_tracks', methods=['POST'])
def search_tracks():
    sp = spotipy.Spotify(auth_manager=SpotifyOAuth(client_id=CLIENT_ID,
                                                   client_secret=CLIENT_SECRET,
                                                   redirect_uri=REDIRECT_URI,
                                                   scope=SCOPE))
    track_name = request.json['track_name']
    results = sp.search(q=track_name, limit=10, type='track')
    tracks = [{'name': track['name'], 'id': track['id']} for track in results['tracks']['items']]
    return jsonify(tracks)

# Route to add tracks to playlist
@app.route('/add_to_playlist', methods=['POST'])
def add_to_playlist():
    sp = spotipy.Spotify(auth_manager=SpotifyOAuth(client_id=CLIENT_ID,
                                                   client_secret=CLIENT_SECRET,
                                                   redirect_uri=REDIRECT_URI,
                                                   scope=SCOPE))
    playlist_id = request.json['playlist_id']
    track_ids = request.json['track_ids']
    sp.user_playlist_add_tracks(user=sp.current_user()['id'], playlist_id=playlist_id, tracks=track_ids)
    return jsonify({'message': 'Tracks added successfully'})

# Route to logout
import os

@app.route('/logout', methods=['POST'])
def logout():
    session.clear()  # Clear the session data
    global sp_oauth
    sp_oauth = SpotifyOAuth(
        client_id=CLIENT_ID,
        client_secret=CLIENT_SECRET,
        redirect_uri=REDIRECT_URI,
        scope=SCOPE,
        show_dialog=True,
        cache_path=".cache"  # Specify cache path to delete it
    )
    
    # Check and delete the cached token file
    if os.path.exists(".cache"):
        os.remove(".cache")
    
    response = make_response(jsonify({"message": "Logged out successfully"}))
    response.headers["Cache-Control"] = "no-store, no-cache, must-revalidate, max-age=0"
    response.headers["Pragma"] = "no-cache"
    return response

if __name__ == '__main__':
    app.run(debug=True, port=8888)

# .\venv\Scripts\activate